// Generated by CoffeeScript 1.3.3
(function() {
  var Canvas1,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Canvas1 = (function(_super) {

    __extends(Canvas1, _super);

    function Canvas1() {
      return Canvas1.__super__.constructor.apply(this, arguments);
    }

    Canvas1.prototype.setup = function() {
      this.fillColor = "#202020";
      this.strokeColor = 'rgba(0, 0, 0, 0.1)';
      this.backgroundColor = 'rgb(240, 240, 240)';
      this.play();
      this.pi = Math.PI * 2;
      this.pointMin = 5;
      this.pointMax = 60;
      return this.Num = 0;
    };

    Canvas1.prototype.update = function() {
      var pointNum;
      pointNum = this.mouseX / this.width * this.pointMax + this.pointMin;
      return this.Num += (pointNum - this.Num) * 0.1;
    };

    Canvas1.prototype.draw = function() {
      var i, j, l, points, _results;
      this.background();
      points = this.getPoints();
      l = points.length;
      i = 0;
      _results = [];
      while (i < l) {
        j = i + 1;
        while (j < l) {
          this.line(points[i][0], points[i][1], points[j][0], points[j][1]);
          j++;
        }
        _results.push(i++);
      }
      return _results;
    };

    Canvas1.prototype.getPoints = function() {
      var centerX, centerY, i, pointNum, points, radius, step, theta, xp, yp;
      centerX = this.width * 0.5;
      centerY = this.height * 0.5;
      radius = this.width;
      if (this.width > this.height) {
        radius = this.height;
      }
      radius *= 0.4;
      pointNum = this.Num >> 0;
      if (pointNum < this.pointMin) {
        pointNum = this.pointMin;
      }
      if (pointNum > this.pointMax) {
        pointNum = this.pointMax;
      }
      step = this.pi / pointNum;
      theta = step * 0.5;
      points = new Array(pointNum);
      i = 0;
      while (i < pointNum) {
        xp = centerX + radius * Math.cos(theta);
        yp = centerY + radius * Math.sin(theta);
        points[i] = [xp, yp];
        theta += step;
        i++;
      }
      return points;
    };

    return Canvas1;

  })(Canvas);

  this.Canvas1 = Canvas1;

}).call(this);
